/* MODULE 3 */
/* Date functions */


/* 1. now */
SELECT DISTINCT
DATE('now') as [now]
,DATETIME() as [right_now]
,datetime('now','localtime') as [right_now_timezone]

/* 2. strftime */
,strftime('%Y-%m','now') as this_year_this_month
,strftime('%Y/%m/%d', '2025-08-10','+50 days') as the_future
,market_date
,strftime('%m-%d-%Y', market_date, '+30 days','-1 year') as the_past

/* 3. adding dates, e.g. last date of the month */
-- last date of the month
,DATE(market_date,'start of month','-1 day') as end_of_previous_month
,DATE(market_date, 'start of month','-1 day','start of month') as start_of_previous_month


/* 4. difference between dates, 
 a. number of days between now and each market_date
 b. number of YEARS between now and market_date
 c. number of HOURS bewtween now and market_date
 */
 ,market_date
 ,julianday('now') - julianday(market_date) as now_md_dd
 ,(julianday('now') - julianday(market_date)) / 365.25 as now_md_dd_yrs
 ,(julianday('now') - julianday(market_date)) * 24 as now_md_dd_hours

 FROM market_date_info
 
 
 /* MODULE 4 */
/* NULL Management */


/* 1. IFNULL: Missing product_size, missing product_qty_type */ 

SELECT * 
,IFNULL(product_size, 'Unknown') as new_product_size
,IFNULL(product_size,product_qty_type) as both_null

/* 2. Coalesce */
,coalesce(product_size,product_qty_type) as still_both_null
,coalesce(product_size, product_qty_type, 'missing') as new_col -- if the first value is null, then the second value, if that is null, then missing

FROM product



/* 3. NULLIF
finding values in the product_size column that are "blank" strings and setting them to NULL if they are blank */
SELECT *
,coalesce(product_size, 'Unknown') as new_product_size
,NULLIF(product_size,'') as nullif_check
,coalesce(NULLIF(product_size,''),'Unknown') as better_product_size

/* 4. NULLIF 
filtering which rows are null or blank */

FROM product

WHERE NULLIF(product_size,'') IS NULL


/* 1. What product is the highest price per vendor */
SELECT 
x.*, product_name

FROM (
	--inner QUERY
	SELECT 
	vendor_id,
	market_date,
	product_id,
	original_price,
	ROW_NUMBER() OVER(PARTITION BY vendor_id ORDER BY original_price DESC) as price_rank

	FROM vendor_inventory
) x
INNER JOIN product p
	ON x.product_id = p.product_id

WHERE price_rank = 1




/* See how this varies from using max due to the group by 
SELECT vendor_id,
--product_id,
MAX(original_price)

FROM vendor_inventory
GROUP BY vendor_id--,product_id

*/

* MODULE 4 */
/* Windowed functions: dense_rank, rank, row_number */


/* 1. Compare dense_rank, rank, and row_number */








DROP TABLE IF EXISTS TEMP.row_rank_dense;

CREATE TEMP TABLE IF NOT EXISTS TEMP.row_rank_dense
(
emp_id INT,
salary INT
);

INSERT INTO temp.row_rank_dense
VALUES
(1,200000),
(2,200000),
(3, 160000),
(4, 120000),
(5, 125000),
(6, 165000),
(7, 230000),
(8, 100000),
(9, 165000),
(10, 100000);


DROP TABLE IF EXISTS TEMP.row_rank_dense;

CREATE TEMP TABLE IF NOT EXISTS TEMP.row_rank_dense
(
emp_id INT,
salary INT
);

INSERT INTO temp.row_rank_dense
VALUES
(1,200000),
(2,200000),
(3, 160000),
(4, 120000),
(5, 125000),
(6, 165000),
(7, 230000),
(8, 100000),
(9, 165000),
(10, 100000),
(11, 90000);

SELECT *
,ROW_NUMBER() OVER(ORDER BY salary desc) as [row_number]
,RANK() OVER(ORDER BY salary desc) as [rank]
,DENSE_RANK() OVER(ORDER BY salary desc) as [dense_rank]

FROM row_rank_dense






/* MODULE 4 */
/* Windowed functions: NTILE */


/* 1. Calculate quartile, quntiles, and percentiles from vendor daily sales */

SELECT *
,NTILE(4) OVER(PARTITION BY vendor_name ORDER BY sales) as [quartile]
,NTILE(5) OVER(PARTITION BY vendor_name ORDER BY sales) as [quintile]
,NTILE(100) OVER(PARTITION BY vendor_name ORDER BY sales) as [percentile]

FROM (

-- vendor daily sales 
	SELECT 
	md.market_date
	,market_day
	,market_week
	,market_year
	,vendor_name
	,SUM(quantity*cost_to_customer_per_qty) AS sales

	FROM customer_purchases AS cp
	JOIN market_date_info AS md
		ON cp.market_date = md.market_date
	JOIN vendor AS v
		ON v.vendor_id = cp.vendor_id
		
	GROUP BY cp.market_date, v.vendor_id
	
) x


-- vendor daily sales 
	SELECT 
	md.market_date
	,market_day
	,market_week
	,market_year
	,vendor_name
	,SUM(quantity*cost_to_customer_per_qty) AS sales

	FROM customer_purchases AS cp
	JOIN market_date_info AS md
		ON cp.market_date = md.market_date
	JOIN vendor AS v
		ON v.vendor_id = cp.vendor_id
		
	GROUP BY cp.market_date, v.vendor_id
	
	/* MODULE 4 */
/* String Manipulations */
SELECT
]



/* 1. ltrim, rtrim, trim*/
SELECT DISTINCT
LTRIM ('           Thomas Rosenthal          ') as [ltrim]
,RTRIM ('           Thomas Rosenthal          ') as [rtrim]
,TRIM ('           Thomas Rosenthal          ') as [trim]

/* 2. replace*/
,REPLACE('THOMAS ROSENTHAL','A','') as [not_my_name]
,customer_first_name
,REPLACE(customer_first_name,'a','') as new_customer_names
,REPLACE(REPLACE(customer_first_name,'a',''),'e','') as more_cust_names
,REPLACE(customer_first_name,'A','') as new_customer_names


/* 3. upper, lower*/
,UPPER(customer_first_name) || ' ' || LOWER(customer_last_name) as FULL_name
,


/* 4. concat with || */
,upper(customer_first_name) || "LOWER (customer_last_name

,customer_first_name
,SUBSTR(customer_first_name,1,4) as first_four
,SUBSTR(customer_first_name,-5,4) as five_four

/* 5. substr */

/* 6. length */

/* 7. unicode, char */
,'

THOMAS 
ROSENTHAL

' as linebreak
,TRIM(REPLACE('

THOMAS 
ROSENTHAL

',char(10), ' ')) as better_line_break

FROM customer

/* 8. REGEXP in a WHERE statement */</sql><sql name="substr_instr_together">/* MODULE 4 */
/* Substring &amp; instring together */

WHERE customer_first_name REGEXP '(a)$' -- filtering to only end in A ... must be valid regex


/* think of this as a comma delimiter ... but it's a bit silly ... do this in python/R instead unless you have to */

SELECT 
'FirstWord, SecondWord, ThirdWord',
 SUBSTR('FirstWord, SecondWord, ThirdWord',0, INSTR('FirstWord, SecondWord, ThirdWord',',')) as FirstDelim
 --,SUBSTR('FirstWord, SecondWord, ThirdWord',0, 10) as FirstDelim -- same thing but not dynamic
 ,SUBSTR('FirstWord, SecondWord, ThirdWord', 
  INSTR('FirstWord, SecondWord, ThirdWord',',')+1,
  INSTR('FirstWord, SecondWord, ThirdWord',',')+1) as SecondDelim
  
  ,SUBSTR('FirstWord, SecondWord, ThirdWord',
  INSTR(
    (SUBSTR('FirstWord, SecondWord, ThirdWord',
    INSTR('FirstWord, SecondWord, ThirdWord',',')+1))
  ,',') + 
  INSTR('FirstWord, SecondWord, ThirdWord',',')+1) AS ThirdDelim
</sql><sql name="UNION_UNION_ALL">/* MODULE 4 */
/* UNION */

/* 1. Find the most and least expensive product by vendor with UNION (and row_number!) */

</sql><sql name="FULL_OUTER_JOIN_UNION">/* MODULE 4 */
/* UNION */

/* 1. Emulate a FULL OUTER JOIN with a UNION */
DROP TABLE IF EXISTS temp.store1; 
CREATE TEMP TABLE IF NOT EXISTS temp.store1
(
costume TEXT,
quantity INT
);

INSERT INTO temp.store1
VALUES(&quot;tiger&quot;,6),
        (&quot;elephant&quot;,2),
        (&quot;princess&quot;, 4);


DROP TABLE IF EXISTS temp.store2;
CREATE TEMP TABLE IF NOT EXISTS temp.store2
(
costume TEXT,
quantity INT
);

INSERT INTO temp.store2
VALUES(&quot;tiger&quot;,2),
	(&quot;dancer&quot;,7),
	(&quot;superhero&quot;, 5);</sql><sql name="INTERSECT_EXCEPT">/* MODULE 4 */
/* INTERSECT &amp; EXCEPT */

/* 1. Find products that have been sold (e.g. are in customer purchases AND product) */ 

/* 1. Find the most and least expensive product by vendor with UNION (and row_number!) */


SELECT  
vendor_id
,product_id
,original_price
,rn_max as [row_number]

FROM (

	SELECT DISTINCT
	vendor_id,
	product_id,
	original_price,
	ROW_NUMBER() OVER(PARTITION BY vendor_id ORDER BY original_price DESC) as rn_max
	
	FROM vendor_inventory

)
where rn_max = 1

UNION  -- UNION, 5 rows; duplicate value for vendor_id 4 product_id 16, UNION ALL returned 6 rows with the duplicate

SELECT  
vendor_id
,product_id
,original_price
,rn_min

FROM (

	SELECT DISTINCT
	vendor_id,
	product_id,
	original_price,
	ROW_NUMBER() OVER(PARTITION BY vendor_id ORDER BY original_price ASC) as rn_min
	
	FROM vendor_inventory

)
where rn_min = 1



/* 1. Emulate a FULL OUTER JOIN with a UNION */
DROP TABLE IF EXISTS temp.store1; 
CREATE TEMP TABLE IF NOT EXISTS temp.store1
(
costume TEXT,
quantity INT
);

INSERT INTO temp.store1
VALUES("tiger",6),
        ("elephant",2),
        ("princess", 4);


DROP TABLE IF EXISTS temp.store2;
CREATE TEMP TABLE IF NOT EXISTS temp.store2
(
costume TEXT,
quantity INT
);

INSERT INTO temp.store2
VALUES("tiger",2),
	("dancer",7),
	("superhero", 5);
	
SELECT s1.costume, s1.quantity as store1_quantity, s2.quantity as store2_quantity, 'top query' as location
FROM store1 s1
LEFT JOIN store2 s2
	ON s1.costume = s2.costume

UNION ALL -- allow for duplicates, because a FULL OUTER join would ALSO allow for duplicates

SELECT s2.costume, s1.quantity, s2.quantity, 'bottom query'
FROM store2 s2
LEFT JOIN store1 s1
	ON s1.costume = s2.costume
WHERE s1.costume IS NULL









/* 2. Find products that have NOT been sold (e.g. are NOT in customer purchases even though in product) */

/* 2. Find products that have NOT been sold (e.g. are NOT in customer purchases even though in product) */

SELECT product_name, x.product_id

FROM (
	SELECT product_id
	FROM product
	EXCEPT
	SELECT product_id
	FROM customer_purchases
) x

INNER JOIN product p on x.product_id = p.product_id;

/* 3. Directions matter... if we switch the order here:
products that do not exist, because no products purchased are NOT in the product table (e.g. are NOT in product even though in customer purchases)*/

SELECT product_id
FROM customer_purchases
EXCEPT
SELECT product_id
FROM product;


/* 4. We can remake the intersect with a WHERE subquery for more details ...  */

SELECT * FROM product
WHERE product_id IN (
	SELECT product_id
	FROM product
	INTERSECT
	SELECT product_id
	FROM customer_purchases
)






/* 3. Directions matter... if we switch the order here:
products that do not exist, because no products purchased are NOT in the product table (e.g. are NOT in product even though in customer purchases)*/



/* 4. We can remake the intersect with a WHERE subquery for more details ...  */


</sql><current_tab id="0"/></tab_sql></sqlb_project>
